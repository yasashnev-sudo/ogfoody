{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/sergejasasnev/Downloads/my-project%20%281%29/app/api/db/%5B...path%5D/route.ts"],"sourcesContent":["// Универсальный API Proxy для NocoDB\n// Все запросы к NocoDB идут через этот route - токен никогда не попадает в браузер\n\nimport { type NextRequest, NextResponse } from \"next/server\"\n\nfunction getNocoDBUrl(): string {\n  return process.env.NOCODB_URL || \"\"\n}\n\nfunction getNocoDBToken(): string {\n  return process.env.NOCODB_TOKEN || \"\"\n}\n\nfunction getTableId(tableName: string): string {\n  const tableIds: Record<string, string | undefined> = {\n    Meals: process.env.NOCODB_TABLE_MEALS,\n    Extras: process.env.NOCODB_TABLE_EXTRAS,\n    Delivery_Zones: process.env.NOCODB_TABLE_DELIVERY_ZONES,\n    Users: process.env.NOCODB_TABLE_USERS,\n    Orders: process.env.NOCODB_TABLE_ORDERS,\n    Order_Persons: process.env.NOCODB_TABLE_ORDER_PERSONS,\n    Order_Meals: process.env.NOCODB_TABLE_ORDER_MEALS,\n    Order_Extras: process.env.NOCODB_TABLE_ORDER_EXTRAS,\n    Promo_Codes: process.env.NOCODB_TABLE_PROMO_CODES,\n    Reviews: process.env.NOCODB_TABLE_REVIEWS,\n    Loyalty_Points_Transactions: process.env.NOCODB_TABLE_LOYALTY_POINTS_TRANSACTIONS,\n    Fraud_Alerts: process.env.NOCODB_TABLE_FRAUD_ALERTS || \"mr9txejs65nk1yi\", // Хардкод фолбэк\n  }\n\n  return tableIds[tableName] || \"\"\n}\n\n// Белый список разрешенных таблиц для безопасности\nconst ALLOWED_TABLES = [\n  \"Meals\",\n  \"Extras\",\n  \"Delivery_Zones\",\n  \"Users\",\n  \"Orders\",\n  \"Order_Persons\",\n  \"Order_Meals\",\n  \"Order_Extras\",\n  \"Promo_Codes\",\n  \"Reviews\",\n  \"Loyalty_Points_Transactions\",\n  \"Fraud_Alerts\",\n]\n\nfunction isAllowedPath(path: string): boolean {\n  const tableName = path.split(\"/\")[0]\n  return ALLOWED_TABLES.includes(tableName)\n}\n\nfunction buildTargetUrl(baseUrl: string, path: string): string {\n  let cleanBaseUrl = baseUrl.replace(/\\/$/, \"\")\n\n  if (!cleanBaseUrl.endsWith(\"/api/v2\")) {\n    cleanBaseUrl = `${cleanBaseUrl}/api/v2`\n  }\n\n  const parts = path.split(\"/\")\n  const tableName = parts[0]\n  const tableId = getTableId(tableName)\n\n  if (!tableId) {\n    throw new Error(\n      `Table ID not configured for \"${tableName}\". Set NOCODB_TABLE_${tableName.toUpperCase()} in environment variables.`,\n    )\n  }\n\n  // Если путь содержит \"records\", оставляем его, иначе добавляем\n  if (parts.length === 1 || !parts[1]?.startsWith(\"records\")) {\n    parts[0] = tableId\n    const newPath = parts.join(\"/\")\n    return `${cleanBaseUrl}/tables/${newPath}`\n  } else {\n    // Если уже есть \"records\" в пути, заменяем только имя таблицы\n    parts[0] = tableId\n    const newPath = parts.join(\"/\")\n    return `${cleanBaseUrl}/tables/${newPath}`\n  }\n}\n\nasync function proxyToNocoDB(request: NextRequest, path: string, method: string): Promise<NextResponse> {\n  const nocodbUrl = getNocoDBUrl()\n  const nocodbToken = getNocoDBToken()\n\n  if (!nocodbUrl || !nocodbToken) {\n    return NextResponse.json(\n      { error: \"NocoDB not configured\", details: { urlSet: !!nocodbUrl, tokenSet: !!nocodbToken } },\n      { status: 503 },\n    )\n  }\n\n  if (!isAllowedPath(path)) {\n    return NextResponse.json({ error: \"Access denied to this resource\" }, { status: 403 })\n  }\n\n  const tableName = path.split(\"/\")[0]\n  const tableId = getTableId(tableName)\n  if (!tableId) {\n    return NextResponse.json(\n      {\n        error: \"Table not configured\",\n        details: `Set NOCODB_TABLE_${tableName.toUpperCase()} environment variable with the Table ID from NocoDB`,\n        tableName,\n        hint: \"Go to NocoDB, open the table, and copy the ID from the URL (e.g., md_xxxxx)\",\n      },\n      { status: 503 },\n    )\n  }\n\n  let targetUrl: string\n  try {\n    targetUrl = buildTargetUrl(nocodbUrl, path)\n  } catch (error) {\n    return NextResponse.json({ error: \"Failed to build URL\", details: String(error) }, { status: 503 })\n  }\n\n  const searchParams = request.nextUrl.searchParams.toString()\n  const fullUrl = searchParams ? `${targetUrl}?${searchParams}` : targetUrl\n\n  try {\n    const headers: HeadersInit = {\n      \"xc-token\": nocodbToken,\n      \"Content-Type\": \"application/json\",\n    }\n\n    const fetchOptions: RequestInit = {\n      method,\n      headers,\n    }\n\n    if ([\"POST\", \"PUT\", \"PATCH\"].includes(method)) {\n      const body = await request.text()\n      if (body) {\n        fetchOptions.body = body\n      }\n    }\n\n    const response = await fetch(fullUrl, fetchOptions)\n    const responseText = await response.text()\n\n    let data\n    try {\n      data = JSON.parse(responseText)\n    } catch {\n      return new NextResponse(responseText, {\n        status: response.status,\n        headers: { \"Content-Type\": \"text/plain\" },\n      })\n    }\n\n    return NextResponse.json(data, { status: response.status })\n  } catch (error) {\n    console.error(\"NocoDB proxy error:\", error)\n    return NextResponse.json({ error: \"Failed to proxy request to NocoDB\", details: String(error) }, { status: 500 })\n  }\n}\n\nexport async function GET(request: NextRequest, { params }: { params: Promise<{ path: string[] }> }) {\n  const { path } = await params\n  const pathString = path.join(\"/\")\n  return proxyToNocoDB(request, pathString, \"GET\")\n}\n\nexport async function POST(request: NextRequest, { params }: { params: Promise<{ path: string[] }> }) {\n  const { path } = await params\n  const pathString = path.join(\"/\")\n  return proxyToNocoDB(request, pathString, \"POST\")\n}\n\nexport async function PUT(request: NextRequest, { params }: { params: Promise<{ path: string[] }> }) {\n  const { path } = await params\n  const pathString = path.join(\"/\")\n  return proxyToNocoDB(request, pathString, \"PUT\")\n}\n\nexport async function PATCH(request: NextRequest, { params }: { params: Promise<{ path: string[] }> }) {\n  const { path } = await params\n  const pathString = path.join(\"/\")\n  return proxyToNocoDB(request, pathString, \"PATCH\")\n}\n\nexport async function DELETE(request: NextRequest, { params }: { params: Promise<{ path: string[] }> }) {\n  const { path } = await params\n  const pathString = path.join(\"/\")\n  return proxyToNocoDB(request, pathString, \"DELETE\")\n}\n"],"names":[],"mappings":"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"}}]
}