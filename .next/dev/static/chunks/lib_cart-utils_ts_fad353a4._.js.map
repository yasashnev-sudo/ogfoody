{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/sergejasasnev/Downloads/my-project%20%281%29/lib/cart-utils.ts"],"sourcesContent":["/**\n * Cart Utilities\n * Вспомогательные функции для работы с корзиной и проверки актуальности товаров\n */\n\nimport type { Order, Person, DayMeals, Meal, Extra, BreakfastSelection, FullMealSelection } from \"./types\"\n\n/**\n * Структура результата валидации заказа\n */\nexport interface OrderValidationResult {\n  /** Обновленный заказ с актуальными товарами */\n  validatedOrder: Order\n  /** Список недоступных товаров */\n  unavailableItems: string[]\n  /** Есть ли недоступные товары */\n  hasUnavailableItems: boolean\n}\n\n/**\n * Интерфейс данных меню из API\n */\ninterface MenuData {\n  breakfast: Meal[]\n  lunch_salad: Meal[]\n  lunch_soup: Meal[]\n  lunch_main: Meal[]\n  dinner_salad: Meal[]\n  dinner_soup: Meal[]\n  dinner_main: Meal[]\n  garnish: Meal[]\n}\n\n/**\n * Проверяет актуальность товаров заказа по текущему меню из API\n * \n * @param order - Заказ для проверки\n * @param currentMenu - Актуальное меню из API\n * @param currentExtras - Актуальные дополнения из API\n * @returns Результат валидации с обновленным заказом и списком недоступных товаров\n * \n * @example\n * const { validatedOrder, unavailableItems, hasUnavailableItems } = validateOrderItems(\n *   historicalOrder,\n *   menuData,\n *   extrasData\n * )\n * \n * if (hasUnavailableItems) {\n *   toast.warning(`Некоторые товары больше недоступны: ${unavailableItems.join(', ')}`)\n * }\n */\nexport function validateOrderItems(\n  order: Order,\n  currentMenu: Record<string, Meal[]>,\n  currentExtras: Record<string, Extra[]>\n): OrderValidationResult {\n  const unavailableItems: string[] = []\n\n  /**\n   * Поиск блюда в текущем меню по ID или имени\n   * ВАЖНО: Используем ТЕКУЩУЮ цену из меню, а не историческую\n   */\n  const findMealInMenu = (mealToFind: Meal | null, categories: string[]): Meal | null => {\n    if (!mealToFind) return null\n\n    // Ищем по всем указанным категориям\n    for (const category of categories) {\n      const menuCategory = currentMenu[category] || []\n      \n      // Сначала пытаемся найти по ID (самый надежный способ)\n      let found = menuCategory.find(m => m.id === mealToFind.id)\n      \n      // Если не нашли по ID, ищем по имени (фолбэк)\n      if (!found) {\n        found = menuCategory.find(m => m.name === mealToFind.name)\n      }\n\n      if (found) {\n        // ✅ КРИТИЧНО: Возвращаем блюдо с ТЕКУЩЕЙ ценой из меню\n        // Но сохраняем выбранную пользователем порцию\n        return {\n          ...found,\n          portion: mealToFind.portion, // Сохраняем выбранную порцию\n          garnish: mealToFind.garnish, // Сохраняем выбранный гарнир (если был)\n        }\n      }\n    }\n\n    // Блюдо не найдено в меню - добавляем в список недоступных\n    unavailableItems.push(mealToFind.name)\n    return null\n  }\n\n  /**\n   * Валидация BreakfastSelection\n   */\n  const validateBreakfast = (breakfast: BreakfastSelection | null | undefined): BreakfastSelection => {\n    if (!breakfast || !breakfast.dish) {\n      return { dish: null }\n    }\n\n    const validatedDish = findMealInMenu(breakfast.dish, ['breakfast'])\n    return { dish: validatedDish }\n  }\n\n  /**\n   * Валидация FullMealSelection (lunch/dinner)\n   */\n  const validateFullMeal = (\n    meal: FullMealSelection | null | undefined,\n    mealType: 'lunch' | 'dinner'\n  ): FullMealSelection => {\n    if (!meal) {\n      return { salad: null, soup: null, main: null }\n    }\n\n    const validatedSalad = meal.salad \n      ? findMealInMenu(meal.salad, [`${mealType}_salad`])\n      : null\n\n    const validatedSoup = meal.soup\n      ? findMealInMenu(meal.soup, [`${mealType}_soup`])\n      : null\n\n    const validatedMain = meal.main\n      ? findMealInMenu(meal.main, [`${mealType}_main`])\n      : null\n\n    // Валидация гарнира для main, если он есть\n    if (validatedMain?.garnish) {\n      const garnishInMenu = findMealInMenu(validatedMain.garnish, ['garnish'])\n      if (validatedMain) {\n        validatedMain.garnish = garnishInMenu\n      }\n    }\n\n    return {\n      salad: validatedSalad,\n      soup: validatedSoup,\n      main: validatedMain,\n    }\n  }\n\n  /**\n   * Валидация DayMeals (day1/day2)\n   */\n  const validateDayMeals = (dayMeals: DayMeals): DayMeals => {\n    return {\n      breakfast: validateBreakfast(dayMeals.breakfast),\n      lunch: validateFullMeal(dayMeals.lunch, 'lunch'),\n      dinner: validateFullMeal(dayMeals.dinner, 'dinner'),\n    }\n  }\n\n  /**\n   * Валидация всех персон в заказе\n   */\n  const validatedPersons: Person[] = order.persons.map(person => ({\n    ...person,\n    day1: validateDayMeals(person.day1),\n    day2: validateDayMeals(person.day2),\n  }))\n\n  /**\n   * Валидация дополнений (extras)\n   * ВАЖНО: Используем ТЕКУЩУЮ цену из extras\n   */\n  const validatedExtras: Extra[] = (order.extras || [])\n    .map(extra => {\n      // Ищем extra во всех категориях\n      const allExtras = Object.values(currentExtras).flat()\n      \n      // Сначала по ID, потом по имени\n      let found = allExtras.find(e => e.id === extra.id)\n      if (!found) {\n        found = allExtras.find(e => e.name === extra.name)\n      }\n\n      if (found) {\n        // ✅ КРИТИЧНО: Возвращаем extra с ТЕКУЩЕЙ ценой\n        return {\n          ...found,\n          quantity: extra.quantity, // Сохраняем количество\n        }\n      }\n\n      // Extra не найден - добавляем в список недоступных\n      unavailableItems.push(extra.name)\n      return null\n    })\n    .filter((extra): extra is Extra => extra !== null)\n\n  // Собираем валидированный заказ\n  const validatedOrder: Order = {\n    ...order,\n    persons: validatedPersons,\n    extras: validatedExtras,\n    // Важно: не копируем цены из старого заказа!\n    // Они будут пересчитаны в OrderModal с актуальными ценами\n    total: undefined,\n    subtotal: undefined,\n    deliveryFee: undefined,\n  }\n\n  return {\n    validatedOrder,\n    unavailableItems,\n    hasUnavailableItems: unavailableItems.length > 0,\n  }\n}\n\n/**\n * Проверяет, есть ли в заказе хотя бы один товар\n */\nexport function hasOrderContent(order: Order): boolean {\n  // Проверяем persons\n  const hasPersons = order.persons.some(person => {\n    const day1HasContent = \n      person.day1.breakfast?.dish ||\n      person.day1.lunch?.salad ||\n      person.day1.lunch?.soup ||\n      person.day1.lunch?.main ||\n      person.day1.dinner?.salad ||\n      person.day1.dinner?.soup ||\n      person.day1.dinner?.main\n\n    const day2HasContent =\n      person.day2.breakfast?.dish ||\n      person.day2.lunch?.salad ||\n      person.day2.lunch?.soup ||\n      person.day2.lunch?.main ||\n      person.day2.dinner?.salad ||\n      person.day2.dinner?.soup ||\n      person.day2.dinner?.main\n\n    return day1HasContent || day2HasContent\n  })\n\n  // Проверяем extras\n  const hasExtras = (order.extras || []).length > 0\n\n  return hasPersons || hasExtras\n}\n\n\n\n"],"names":[],"mappings":"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"}}]
}